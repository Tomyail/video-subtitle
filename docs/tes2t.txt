大家好，我是 Tony Alicea，在本视频中，我们将深入了解名为 quick 的新可恢复 JavaScript框架，什么是 Quicks Innovations 以及它如何实现它们，我们将看几个示例 我们将深入研究它的源代码，我们将尽最大努力真正理解[Music]在该视频发布时 quick 刚刚发布到 beta 版，您可以在 quick qwik.builder.io和我找到它 在操场上，  我们可以快速尝试我已经编写了一个基本组件它只有一个按钮，单击该按钮时会提示我的名字，并且我已经将我的名字存储在一个具有快速语法的变量中在对组件美元符号的调用中包装一个函数，这使该函数成为一个快速组件，传递给浏览器的实际 HTML正在服务器上呈现，我现在最终在这里看到了该应用程序 Watch WhatHappens down in this console when 我点击了警报发生的按钮，嗨，  托尼在控制台下方我们看到加载了两个JavaScript 文件，这个长名称和 app2.js那么为什么要下载这些文件以及它们在哪些方面做得很好首先让我们转到 HTML 如果我向下滚动单击此按钮时发生了什么我 我很快就会看到很多 Q 冒号已经将额外的信息放入 HTML 中，将其序列化信息放入 HTML 中，以便稍后可以在这里做出决定，  例如我的点击美元符号被转换为冒号点击和内部 其中一个是这个长的Javascript 文件名后跟一个井号，然后是另一个名称，这是关于点击我正在编写的代码首先要注意的事情之一，而不是传递给浏览器的代码点击会自动拆分我的 编写代码，当我转到 app2 时，我们可以在 playground 的客户端包中看到它实际上看起来只是快速源代码，但如果我转到这些其他文件，我可以看到我的组件 这是我的名字，  jsx 被转换为jsx 当然很像它在 react 中其他框架被转换为JavaScript 代码以创建对象树，我们看到点击美元符号而不是直接被函数包装在 它自己的函数称为 qrl，然后动态导入这个带有长名称的 Javascript 文件，并传递另一个长名称这里有一行额外的代码，使用一种叫做使用词法范围的东西来访问名字，然后这个函数在这个文件的末尾被导出，所以这是很多事情，  如果我回到交付的 HTML还有更多通过服务器，我向下滚动一种方式，我也可以找到这个 Json信息块，还有 Tony，这是我在名字中输入的值，还有另一个ID 为 quick l 的脚本 oader 看起来是一堆代码，尽管实际上并没有那么多最后还有另一个脚本将字符串值推送到称为快速事件的东西中，  这是全局的所以为什么所有这些都在这里它在做什么以及它允许​​快速完成什么 我们将看一下 quick 的两个特殊功能包括您所看到的优化器和快速加载器 首先让我们看一下优化器 我将进入快速源代码 我将单击此处的链接 对于 GitHub 中的源代码，我可以在其中获取它，然后将其全部下载到我的机器中并在Visual Studio 代码中打开它，它在包下，我将转到快速文件夹源，  然后我会找到一个 称为优化器的文件夹在该文件夹下是核心，有源代码，我有一堆文件，但它们不是 JS 文件，它们是点 RS 文件，这段代码是用 Rust 编程语言编写的，它现在做得很好我 注意一个文件called parse 并且当我看到一个名为 parse 的文件时，我开始认为这是在以某种方式查看文本和更改文本，而这正是快速优化器正在发生的事情快速优化器在某种程度上是一个编译器，  它正在获取代码 我写了那些JS 文件检查它并根据我的代码创建新文件，这些代码实际交付给浏览器的 JavaScript引擎以执行，并且在这个优化器中它有一些对于快速快速重要的短语，例如组件美元符号或只是美元符号 一般这里所说的 q 钩子意味着每次我看到美元符号时，优化器在分析这个文件的这段文本时都会以不同的方式对待它，这意味着当我看到点击美元时，基本上我应该拆分代码这意味着我将有一些代码，  通常是一个函数应该被拉入它自己的文件中，这就是优化器将要执行的操作 timizer 本质上是说 preparefor this function to be lazy loaded bylazy loading 这意味着它将在实际需要时单独下载和执行所以你可以把美元符号想象成请延迟加载这不要打扰要求 JavaScript 引擎解析并处理它，直到你需要它，换句话说，  优化器的正确心智模型和点击是文本处理器的心智模型我们给优化器一些我们编写的代码，当它找到美元符号时，它会占用我们的主体代码并创建一个新文件，然后在我们的代码所在的位置将其替换为对该新文件的引用以及对 quick 称为符号的引用，我们可以将其视为仅从中导出的变量 new file我在哪里可以找到这个应该执行的函数如果你想象这是在你的整个应用程序中完成的，那么你最终会得到很多小文件，  这些文件很快被称为块 wh  ich 随着时间的推移可能会或可能不会被浏览器执行执行这些函数的调用被包裹在一个叫做 qrl 的东西中它似乎显然受到URL 或地址的想法的启发所以qrl 函数内部发生的事情来自quickwell 让我们 回到当页面实际发送到浏览器时交付的 HTML 有一个称为快速加载程序的脚本，  这是我们在拥有所有这些准备好延迟加载的单独文件后要看的另一块拼图 我们需要能够实际响应事件、点击和用户所做的事情然后延迟加载这些文件，这就是快速加载程序，基本上就是您第一次加载时实际要加载的 JavaScript 快速应用程序，现在几乎没有其他东西了，这个版本的快速加载器被缩小了，有点难以阅读所以让我们在源代码级别看一下它，我可以在快速 SRC 和quickloader.ts现在请注意，  在录制此视频时quick 处于测试阶段，此代码的结构将发生变化代码中的内容将发生变化，但我们并没有试图理解我们正在尝试的 quick 源代码的结构了解它是如何尝试做它做的事情的，所以快速加载器在做什么，如果我向下滚动一点，qrl 是如何工作的，我会找到 qrl 解析器，所以当我给它一个 qrl 字符串时，它实际上会转换 在一个URL 中，我们应该去获取文件的实际地址，这样才有意义，  但是如果我们向下滚动我们会看到一个调度，这通常意味着一个事件已经发生，那么事件如何与去获取文件和执行它相关联我们实际上可以看到我们正在寻找一个以on 开头然后是冒号的属性名称，然后是事件名称记得我们在冒号单击时看到如果我进一步向下滚动我可以看到当我们查看事件的值时 记得在冒号上点击是p 指出优化器创建的那些 JavaScript 文件之一的 Javascript 文件名，它解析该 URL，  它计算出它应该获得的确切地址然后在某个时候它实际上会读取它，记住有一个井号，所以它忽略了井号后面的文本是符号名称，只是基于该 URL 导入，所以当我们返回并查看点击时它会处理此事件，然后在该事件发生时导入此 JS 文件，然后它是 将有一个带有该 URL 的符号名称部分的模块，请记住在 JS 文件之后有一个井号，然后是一个符号名称，因此它将从导出的模块中找到它，  我们可以看到在客户端包中最后有 导出的名称与井号后的名称相同此时它现在具有应该调用 Handler 的函数，最终它会执行 Handler，因此它正在获取代码和 ex 执行它，这就是我的点击事件函数是如何运行的，但是这些事件是如何被标记的，因为冒号点击不是一个正常的浏览器属性，如果我向下滚动一种方式，我实际上会发现事件被添加到文档本身所以 quick 正在添加我们称之为全局侦听器的东西，  它正在文档中的任何位置寻找这些事件中的任何一个我实际上可以在下面看到它正在添加一个全局点击侦听器，所以我单击的任何地方都将通过快速加载器响应，如果我是在我的按钮上添加另一个事件，例如模糊，我不会做任何事情，但让我们假装我现在做了 快速加载器的模型，当你第一次运行一个快速应用程序时，JavaScript 代码总是存在的，它正在添加全局事件监听器，所以如果我把文档看作一棵树，  因为文档对象模型是 s 结构化我没有在树的特定元素上监听事件而是在全局监听，所以如果我们说一个按钮从 Quick 的角度来看有一个点击事件，那么 quick 称为合成事件，因为实际上只有一个全局监听事件不是当我单击按钮时，实际上是一个直接在浏览器中的按钮上监听的事件，实际发生的是整个文档的单击事件被触发，现在快速加载器知道如果这是您的第一次交互，它需要做一些工作单击它实际上会自己快速下载，  我们在 app2.js 中看到了这一点但随后它会查看实际单击按钮的内容，然后找出哪个组件以及该组件中的哪个函数应该实际响应该事件，最终我们' 我将查看 qrl 并执行正确的函数该函数位于一个单独的文件中由优化器创建的一个单独的块，  该函数执行 tes 和我现在得到了正确的功能这里有一点需要注意这是不够的它实际上并不能完全工作为什么让我们运行我们自己的代码我们手动添加一个点击监听器到一个按钮而不是在我的 HTML 中使用快速我 有一个 ID 为 BTN 的按钮我创建了一个名为 addclick Handler 的函数 我把我的名字放在这里 我正在添加一个事件监听器，  使用浏览器提供给 JavaScript 引擎的功能来添加一个点击 监听器我给它一个函数，我只是要提醒你好，然后这个名字变量，然后我运行这个函数，所以如果我点击它，它会说你好，托尼，太棒了，这个函数是怎么做到的点击处理程序知道 名字的值好吧，这是因为闭包的特性，记住 JavaScript在处理完这个事件侦听器后继续运行代码，所以所有这些代码都完成了，然后当我单击按钮时，这个函数对象被执行，  但它有一个 访问名字变量即使此广告点击处理程序函数已完成执行并且基本上消失了，因为 JavaScript 在创建函数对象时会维护函数创建时围绕函数的值，换句话说，如果不是创建函数 我立即执行了它，它可以访问所有变量，如果它在那个时候被执行的话，它可以访问的所有变量让我们调用闭包和我们在我的其他视频中讨论过的东西，  这很棒并且可以作为 预期即使创建了函数对象但直到稍后才执行它仍然可以访问名字但是让我们尝试一些不同的东西假设我有一个文件我基本上会做优化器所做的事情我会把点击处理程序放在它自己的文件中 并且只需要带有引用的警报然后我将更改添加事件侦听器，以便它添加 The Click 但它是一个异步函数，  可以动态导入 J  avascript 文件所以浏览器会出去获取这个文件抓住点击处理程序然后执行它但是只有在我点击之后让我们看看会发生什么如果我查看控制台我看到我有一个错误名字未定义函数做了如果我要将函数更改为不引用它工作的变量则无法访问变量的名字，但是如果我尝试访问它，我会收到一个错误动态导入这个从模块导入的 JavaScript 的问题，  这个 方法意味着 JavaScript 引擎不会设置此单击处理程序函数以通过闭包对这些其他变量进行任何访问因此这个简单的示例不起作用以便延迟加载我的 JavaScript函数我需要以某种方式提供函数 JavaScript 引擎通常会给它闭包它应该访问的函数之外的变量，然后我们开始瞥见什么 quick 正在做 请注意，  这里的代码本质上是等效的 它是延迟加载此警报 运行该警报的函数但它可以工作并且可以访问闭包内的变量 quick是通过序列化存储闭包信息的闭包来实现的例如在交付的 HTML 中，我们已经看到Tony 在这个 Json 对象中，当我们向上看点击事件的结尾时，实际上有一个对数组中值的引用，  所以很快就可以使用数组并将事物序列化为HTML 和这个 Json 本质上做的是浏览器没有存储延迟加载函数应该访问的信息允许我们正常编写代码让我们看一个稍微复杂的例子看看我将用计数器替换它我的组件正在使用快速的使用存储功能，以便让组件保持状态，即它维护和更新的信息我设置了一个妙招 le 的随机值，但我们可以在源代码中轻松找到一些东西然后我说告诉我计数的值，然后点击增加计数，无论增量变量是什么，  请注意对于这个点击函数计数和增量都是一部分闭包的数量取决于此函数之外的存储和递增，这将被延迟加载，因为我已经指定了这个美元符号这里有一些在许多 JavaScript 框架的 HTML 中需要注意的事情这个 987 实际上是占位符并且在 在浏览器中，这个占位符将被替换为 987，但这里的 HTML 是在服务器上生成的，所以我在 HTML 中实际得到的是 Count 冒号，  然后是 store.count 的值但是如果我单击该值，JavaScript 就会发生变化下载并在许多其他框架中更新 Dom 中的值来执行此操作需要称为水化的东西我们的意思是你如何知道所有这些 HTML 中的位置 是将此值 987 更新为现在应为 992 的正确点。为此，许多其他框架实际上会重新计算整个对象树，即应在浏览器上创建的整个元素树，然后将其与 Dom 中有什么，  然后对 Dom 进行逆向工程说得好，这实际上是这里组件的一部分，所以这是应该运行的函数等等，但很快又是关于序列化信息以供以后使用的，所以 我们实际上可以看到组件边界信息，这意味着这里是这个组件开始部分的地方，这里是这个组件结束部分的地方注意甚至还有一个 ID 组件的键，这与我的组件的文件名相同的 ID这么快 只需查看它自己的HTML 即可了解哪些HTML 片段是由哪个组件创建的，  因此点击事件将执行延迟加载的 JavaScr  ipt 并且当 quick去更新 Dom 时它知道在哪里做它而不必在内部重新创建所有 HTML以找出进行更新的适当位置它只是在正确的位置更新这是快速调用的所有部分恢复能力意味着此信息是在 987 年从服务器传送的但现在控制交互的浏览器能够继续进行计算、更新和交互，  而无需快速重做在服务器上完成的任何工作不必说应该有一个 P 和一个带冒号的计数987 和另一个 p 然后找出它在哪里并比较或任何其他类似的方法它能够从服务器获取这个 HTML 并且恢复应用程序的执行接收一个事件并执行适当的操作而无需运行更多的JavaScript所以再次思考我们快速加载器的心理模型以及它需要什么 ick 正在执行事件发生这实际上是一个全局事件，  并且 quick 已经完成的操作之一因为信息已经存在，本质上是重新创建作为该文件的一部分发生的闭包，然后执行该文件并在我执行时执行该函数 查看客户端包，然后查看我的延迟加载函数，有一个名为 use lexical scope 的 quick 特性，它实际上拉入增量和存储，然后我的代码就在那里，那些本来可以通过闭包使用的值由 很快，这些闭包是可用的，因为它们已经被序列化到 HTML 中，  记住增量是 5计数是987，如果我在这个 Json 中向下看，那两个值是，但我不必考虑任何 这是因为 quick 使用其优化器和快速加载器 Etc 正在处理工作以使其以惰性加载的方式工作我认为这是一种令人着迷的处理方法大型 JavaScript框架和大型应用程序的许多缺点，特别是知道世界上有很多人正在处理速度慢的互联网预付费互联网计划缓慢的手机处理器速度较慢等，当您考虑使用快速构建的应用程序时，  您可以 想想用户在应用程序中进行各种点击和操作的事件序列这些点击和操作可能会导致新屏幕或屏幕的新状态，当我四处走动时，JavaScript正在实际加载到生产中，快速完成很多预取意义 它下载了JavaScript，但还没有真正执行它，这很好，  因为我们本质上是在利用现实世界的暂停我用户打开一个屏幕我不会立即采取行动至少从计算机的角度来看我没有时间 移动我的鼠标并快速单击或点击屏幕有足够的时间来下载一些东西有时甚至是根据页面上可见的内容来下载一些东西，这样它就可以 单击时不必进行下载，但无论哪种方式，实际执行的 JavaScript 都基于我在应用程序中所做的事情，而不仅仅是我要访问的页面，  而是在事件的交互级别将我在网页或 Web 应用程序上实际交互的内容与延迟加载后正在执行的 JavaScript 相对应因此无论我的 JavaScript 应用程序有多大，我都只会下载和执行必须加载的 JavaScript处理我在应用程序中所做的事情的顺序，我认为这很重要，它本质上是一种内置的性能提升，  我开发人员真的不需要做太多你认为我希望这种心态是什么JavaScript 框架的未来这就是它在可恢复 JavaScript 框架的幕后如果您喜欢这个视频请查看说明中的链接以快速访问我在 patreon.com 上的 patreon以及我在 YouTube 上的频道，  查看我对 angularjs angular 和 co 的 mishko haveri 创建者的采访- quick 的创建者了解更多详细信息当然您可以订阅我的频道以获取更多视频感谢您的观看和愉快的编码，